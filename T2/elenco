#!/usr/bin/python3
import sys
import time
from functools import cmp_to_key

OPT = sys.maxsize
Xopt = []
atores = []
l = 0       # num de grupos
m = 0       # num de atores
n = 0       # num de personagens
count = 0
# argumentos:
lim_dada    = False # usar função limitante dos profs.
corte_via   = True  # cortes de viabilidade
corte_oti   = True  # cortes de otimalidade

class Ator:
    def __init__(self, valor, grupos, id):
        self.valor = valor
        self.grupos = grupos
        self.id = id

    def print(self):
        print("Valor:", self.valor, "Grupos:", self.grupos, "Id:", self.id)


def main():
    # obtém entrada em formato de lista (um item para cada linha)
    entrada = sys.stdin.readlines()
    # retira os \n de cada linha de entrada
    for i, linha in enumerate(entrada):
        entrada[i] = linha.replace("\n", "")

    linha = entrada[0].split(" ")
    global l
    global m
    global n
    l = int(linha[0]) # num de grupos
    m = int(linha[1]) # num de atores
    n = int(linha[2]) # num de personagens
    global atores
    n_linha = 1
    atores = []
    Escolhidos = []
    Faltam = []
    # lê informação de cada ator
    for i in range(m):
        linha = entrada[n_linha].split(" ")
        valor = int(linha[0])
        
        s = int(linha[1])
        grupos = []
        n_linha += 1

        for j in range(s):
            grupos.append(int(entrada[n_linha]))
            n_linha += 1

        atores.append(Ator(valor, grupos, i + 1))

    time_start = time.time()
    if not lim_dada:
        atores.sort(key=lambda x: x.valor)
        
    Faltam = atores.copy()

    resolver(0, Escolhidos, Faltam)
    time_end = time.time()
    
    global OPT
    global Xopt
    global count
    if OPT != sys.maxsize:
        Xopt.sort(key=ordenaId)
        # print 1 ele.
        print(Xopt[0].id, end="")
        # print resto
        for i in range(1, len(Xopt)):
            print(" " + str(Xopt[i].id), end="")
        print()
        print(OPT)
    else:
        print("Inviável")

    print(count, file=sys.stderr)
    print(time_end - time_start, file=sys.stderr)

# função limitante que o prof deu
def limitanteDada(Escolhidos, Faltam):
    global n
    total = 0
    # faz o somatório
    for ator in Escolhidos:
        total += ator.valor

    total += (n - len(Escolhidos))* minimo(Faltam) 
    return total

def limitanteFeita(indice, Escolhidos, Faltam):
    global n    # num de personagens
    # o array de atores faltando está ordenado por menor valor por número de
    # grupos que o ator satisfaz 
    grupos = []
    total = 0
    for ator in Escolhidos:
        total += ator.valor

    for i in range(n - len(Escolhidos) - len(Faltam)):
        total += ator.valor

    return total

# calculando o valor mínimo de um ator numa lista de atores
def minimo(atores):
    n_atores = len(atores)
    if (n_atores == 0):
        return 0    
    # assume como mais barato o primeiro do array
    min = atores[0].valor
    for i in range(1, n_atores):
        if (atores[i].valor < min):
            min = atores[i].valor
    return min
    
def verificaViabilidade(Escolhidos):
    global l
    global n
    # verifica se o num de atores escolhidos está correto
    if (len(Escolhidos) != n):
        return (False, 0)
    # verifica se todos os grupos estão representados
    grupos = dict()
    valor = 0
    for ator in Escolhidos:
        valor += ator.valor
        for n_grupo in ator.grupos:
            grupos[n_grupo] = 1

    if (len(grupos) < l):
        return (False, 0)
        
    return (True, valor)

def resolver(indice, Escolhidos, Faltam):
    global OPT      # sol. ótima
    global Xopt     # val. sol. ótima
    global n        # num. personagens
    global m        # num. atores
    global atores   # array contendo todos os atores
    global lim_dada # usar função limitante dos profs.
    global corte_via# cortes de viabilidade
    global corte_oti# cortes de otimalidade
    global count
    count += 1
    
    # verifica se o grupo de atores escolhidos é viável
    (viavel, novo_val) = verificaViabilidade(Escolhidos)
    if viavel:
        if novo_val < OPT:
            OPT = novo_val
            Xopt = Escolhidos
    # não tem mais atores para escolher
    if(indice >= m):
        return
    # faz o corte de viabilidade (as escolhas de atores restantes formam uma resposta possível?)
    if corte_via:
        if cortaViabilidade(Escolhidos, Faltam):
            return
    # faz o corte de otimalidade (existe a possibilidade uma escolha de atores mais barata?)
    if corte_oti:
        B = OPT
        if lim_dada:
            B = limitanteDada(Escolhidos, Faltam)
        else:
            B = limitanteFeita(indice, Escolhidos, Faltam)

        if (B >= OPT):
            return
    
    # ainda falta escolher atores        
    E = Escolhidos.copy()
    F = Faltam.copy()
    ator = F.pop(0)
    # decido não escolher ator
    resolver(indice + 1, E, F)
    # decido escolher ator
    E.append(ator)
    resolver(indice + 1, E, F)


def escolheAtor(E, F, ator):
    for a in F:
        if (a.id == ator.id):
            F.remove(a)
            break

    E.append(ator)
    
def cortaViabilidade(Escolhidos, Faltam):
    global l        # num de grupos
    global n        # num. personagens
    global m        # num. atores
    global atores   # array contendo todos os atores
    
    if (len(Faltam) + len(Escolhidos) < n ):
        return True # se for menos que precisamos, corta

    # verifica se o número de grupos (distintos) dos personagens escolhidos + o número de
    # grupos dos atores restantes (que não foram escolhidos) satisfaz o valor mínimo
    grupos = dict()
    for ator in Escolhidos:
        for n_grupo in ator.grupos:
            grupos[n_grupo] = 1
    
    for ator in Faltam:
        for n_grupo in ator.grupos:
            grupos[n_grupo] = 1
    
    if (len(grupos) < l):
        return True

    return False

def printLista(lista):
    for item in lista:
        item.print()


if __name__ == "__main__": 
    for arg in sys.argv:
        if arg == "-a":
            lim_dada  = True
        if arg == "-f":
            corte_via = False
        if arg == "-o":
            corte_oti = False
    main()