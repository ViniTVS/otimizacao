#!/usr/bin/python3
import sys

OPT = sys.maxsize
Xopt = []
atores = []
l = 0 # num de grupos
m = 0 # num de atores
n = 0 # num de personagens

class Ator:
    def __init__(self, valor, grupos):
        self.valor = valor
        self.grupos = grupos

    def print(self):
        print("Valor:", self.valor, "Grupos:", self.grupos)

def main():
    # obtém entrada em formato de lista (um item para cada linha)
    entrada = sys.stdin.readlines()
    # retira os \n de cada linha de entrada
    for i, linha in enumerate(entrada):
        entrada[i] = linha.replace("\n", "")

    linha = entrada[0].split(" ")
    global l
    global m
    global n
    l = int(linha[0]) # num de grupos
    m = int(linha[1]) # num de atores
    n = int(linha[2]) # num de personagens
    global atores
    n_linha = 1
    atores = []
    atores_escolhidos = []
    atores_faltando = []

    for i in range(m):
        linha = entrada[n_linha].split(" ")
        valor = int(linha[0])
        
        s = int(linha[1])
        grupos = []
        n_linha += 1

        for j in range(s):
            grupos.append(int(entrada[n_linha]))
            n_linha += 1

        atores.append(Ator(valor, grupos))
        atores_faltando.append(Ator(valor, grupos))


    # print(limitanteDada(atores_escolhidos, atores_faltando)
    # print(verificaViavel(atores_escolhidos))
    resolver(0, atores_escolhidos, atores_faltando)
    global OPT
    global Xopt
    print("\n\n\nResultado:")
    print(OPT)
    printLista(Xopt)

# função limitante que o prof deu
def limitanteDada(atores_escolhidos, atores_faltando):
    global n
    total = 0
    # faz o somatório
    for ator in atores_escolhidos:
        total += ator.valor

    total += (n - len(atores_escolhidos))* minimo(atores_faltando) 
    return total

    
# calculando o valor mínimo de um ator numa lista de atores
def minimo(atores):
    n_atores = len(atores)
    if (n_atores == 0):
        return 0    
    # assume como mais barato o primeiro do array
    min = atores[0].valor
    for i in range(1, n_atores):
        if (atores[i].valor < min):
            min = atores[i].valor

    return min

def verificaViavel(atores_escolhidos):
    global l
    global n
    # verifica se o num de atores escolhidos está correto
    if (len(atores_escolhidos) != n):
        return (False, 0)
    # verifica se todos os grupos estão representados
    grupos = []
    valor = 0
    for ator in atores_escolhidos:
        valor += ator.valor
        for grupo in ator.grupos:
            if not(grupo in grupos):
                grupos.append(grupo)

    if (len(grupos) != l):
        return (False, 0)
    
    return (True, valor)

def resolver(indice, Escolhidos, Faltam):
    global OPT
    global Xopt
    global n
    global atores

    print("\n\nindice:", indice)
    print("Escolhidos:")
    printLista(Escolhidos)
    print("Faltam:")
    printLista(Faltam)

    # já escolhemos o número de atores
    (viavel, novo_val) = verificaViavel(Escolhidos)
    if viavel:
        if novo_val < OPT:
            OPT = novo_val
            Xopt = Escolhidos
    # ainda falta escolher atores
    if (len(Escolhidos) < n):
        # não posso escolher um ator fora do índice
        if(indice >= len(atores)):
            return
        E = Escolhidos.copy()
        F = Faltam.copy()
        # não escolho ator
        print("\nNão escolho:", indice)
        resolver(indice + 1, E, F)
        # E = Escolhidos.copy()
        # F = Faltam.copy()
        
        # decido escolher ator
        print("\nEscolho:", indice)
        escolheAtor(E, F, atores[indice])
        resolver(indice + 1, E, F)


def escolheAtor(E, F, ator):
    for a in F:
        if (a.valor == ator.valor and set(a.grupos) == set(ator.grupos)):
            F.remove(a)
            break

    E.append(ator)
    
    
#     return 0
def printLista(lista):
    for item in lista:
        item.print()


if __name__ == "__main__":
    main()