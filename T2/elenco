#!/usr/bin/python3
import sys
from functools import cmp_to_key

OPT = sys.maxsize
Xopt = []
atores = []
l = 0       # num de grupos
m = 0       # num de atores
n = 0       # num de personagens
count = 0
# argumentos:
lim_dada    = False # usar função limitante dos profs.
corte_via   = True  # cortes de viabilidade
corte_oti   = True  # cortes de otimalidade

class Ator:
    def __init__(self, valor, grupos, id):
        self.valor = valor
        self.grupos = grupos
        self.id = id
        self.v_grupo = (valor / len(grupos))

    def print(self):
        print("Valor:", self.valor, "Grupos:", self.grupos, "Id:", self.id, "Valor/grupo:", self.v_grupo)


def ordId(a, b):
    if (a.id > b.id):
        return 1
    return -1

def ordVGrupo(a, b):
    if (a.v_grupo > b.v_grupo):
        return 1
    elif (a.v_grupo == b.v_grupo and len(a.grupos) < len(b.grupos)):
        return 1
    return -1

ordenaId = cmp_to_key(ordId)
ordenaValGrupo = cmp_to_key(ordVGrupo)



def main():
    # obtém entrada em formato de lista (um item para cada linha)
    entrada = sys.stdin.readlines()
    # retira os \n de cada linha de entrada
    for i, linha in enumerate(entrada):
        entrada[i] = linha.replace("\n", "")

    linha = entrada[0].split(" ")
    global l
    global m
    global n
    l = int(linha[0]) # num de grupos
    m = int(linha[1]) # num de atores
    n = int(linha[2]) # num de personagens
    global atores
    n_linha = 1
    atores = []
    atores_escolhidos = []
    atores_faltando = []
    # lê informação de cada ator
    for i in range(m):
        linha = entrada[n_linha].split(" ")
        valor = int(linha[0])
        
        s = int(linha[1])
        grupos = []
        n_linha += 1

        for j in range(s):
            grupos.append(int(entrada[n_linha]))
            n_linha += 1

        atores.append(Ator(valor, grupos, i + 1))
        atores_faltando.append(Ator(valor, grupos, i + 1))


    resolver(0, atores_escolhidos, atores_faltando)
    global OPT
    global Xopt
    global count
    if OPT != sys.maxsize:
        Xopt.sort(key=ordenaId)
        # print 1 ele.
        print(Xopt[0].id, end="")
        # print resto
        for i in range(1, len(Xopt)):
            print(" " + str(Xopt[i].id), end="")
        print()
        print(OPT)
    else:
        print("Inviável")

    print(count, file=sys.stderr)


# função limitante que o prof deu
def limitanteDada(atores_escolhidos, atores_faltando):
    global n
    total = 0
    # faz o somatório
    for ator in atores_escolhidos:
        total += ator.valor

    total += (n - len(atores_escolhidos))* minimo(atores_faltando) 
    return total


def limitanteFeita(atores_escolhidos, atores_faltando):
    global l    # num de grupos
    global m    # num de atores
    global n    # num de personagens
    # o array de atores faltando está ordenado por menor valor por número de
    # grupos que o ator satisfaz 
    grupos = []
    total = 0
    for ator in atores_escolhidos:
        total += ator.valor
        
    total += atores_faltando[0].valor
    return total





# calculando o valor mínimo de um ator numa lista de atores
def minimo(atores):
    n_atores = len(atores)
    if (n_atores == 0):
        return 0    
    # assume como mais barato o primeiro do array
    min = atores[0].valor
    for i in range(1, n_atores):
        if (atores[i].valor < min):
            min = atores[i].valor
    return min
    
def verificaViabilidade(atores_escolhidos):
    global l
    global n
    # verifica se o num de atores escolhidos está correto
    if (len(atores_escolhidos) != n):
        return (False, 0)
    # verifica se todos os grupos estão representados
    grupos = []
    valor = 0
    for ator in atores_escolhidos:
        valor += ator.valor
        for grupo in ator.grupos:
            if not(grupo in grupos):
                grupos.append(grupo)

    if (len(grupos) < l):
        return (False, 0)
        
    return (True, valor)

def resolver(indice, Escolhidos, Faltam):
    global OPT      # sol. ótima
    global Xopt     # val. sol. ótima
    global n        # num. personagens
    global m        # num. atores
    global atores   # array contendo todos os atores
    global lim_dada # usar função limitante dos profs.
    global corte_via# cortes de viabilidade
    global corte_oti# cortes de otimalidade
    global count
    count += 1
    
    # verifica se o grupo de atores escolhidos é viável
    (viavel, novo_val) = verificaViabilidade(Escolhidos)
    if viavel:
        if novo_val < OPT:
            OPT = novo_val
            Xopt = Escolhidos
    # não tem mais atores para escolher
    if(indice >= m):
        return
    # faz o corte de viabilidade (as escolhas de atores restantes formam uma resposta possível?)
    if corte_via:
        if cortaViabilidade(indice, Escolhidos):
            return
    # faz o corte de otimalidade (existe a possibilidade uma escolha de atores mais barata?)
    if corte_oti:
        B = OPT
        if lim_dada:
            B = limitanteDada(Escolhidos, Faltam)
        else:
            B = limitanteDada(Escolhidos, Faltam)

        if (B >= OPT):
            return
    
    # ainda falta escolher atores        
    E = Escolhidos.copy()
    F = Faltam.copy()
    # decido não escolher ator
    resolver(indice + 1, E, F)
    # decido escolher ator
    escolheAtor(E, F, atores[indice])
    resolver(indice + 1, E, F)


def escolheAtor(E, F, ator):
    for a in F:
        if (a.id == ator.id):
            F.remove(a)
            break

    E.append(ator)
    
def cortaViabilidade(indice, Escolhidos):
    global l        # num de grupos
    global n        # num. personagens
    global m        # num. atores
    global atores   # array contendo todos os atores
    # o número máximo de personagens que podemos ter com a atual seleção é:
    # |A| - índice (mas como vetores começam de 0, soma 1) + |E| 
    if (m - (indice + 1) + len(Escolhidos) < n ):
        return True # se for menos que precisamos, corta

    # verifica se o número de grupos (distintos) dos personagens escolhidos + o número de
    # grupos dos atores restantes (que não foram escolhidos) satisfaz o valor mínimo
    grupos = []
    for ator in Escolhidos:
        for grupo in ator.grupos:
            if not(grupo in grupos):
                grupos.append(grupo)
    
    for i in range(indice, m):
        for grupo in atores[i].grupos:
            if not(grupo in grupos):
                grupos.append(grupo)
    
    if (len(grupos) < l):
        return True

    return False


#     return 0
def printLista(lista):
    for item in lista:
        item.print()


if __name__ == "__main__":
    
    for arg in sys.argv:
        if arg == "-a":
            lim_dada  = True
        if arg == "-f":
            corte_via = False
        if arg == "-o":
            corte_oti = False
    main()